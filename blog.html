
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="author" content="MarkdownViewer++" />
        <title>blog.md</title>
        <style type="text/css">
            
/* Avoid page breaks inside the most common attributes, especially for exports (i.e. PDF) */
td, h1, h2, h3, h4, h5, p, ul, ol, li {
    page-break-inside: avoid; 
}

        </style>
      </head>
    <body>
        <h1 id="underground-coding"><a href="UndergroundCoding.github.io/">Underground Coding</a></h1>
<h2 id="the-underground-blog">The Underground Blog</h2>
<h3 id="episode-01-i-start-a-blog">Episode 01: I Start a blog</h3>
<h4 id="may-29-2021">May 29, 2021</h4>
<p>Today I started a blog. I'm not sure if it will be program specific, or dev specific, or specific at
all. I don't even know if I will keep itreading, but I will at least write and commit this entry.</p>
<p>This blog is (will be) hosted on github, initially as a markdown file but later as a website
(through github pages).</p>
<p>Anyway I've been wanting to list my struggles; my learnings;-and-; my victories. It is important to
anchor your path by remembering the beginnings.</p>
<h3 id="episode-02-a-tale-of-libccrtp">Episode 02: A Tale of libccrtp.</h3>
<h4 id="may-29-2021-1">May 29, 2021</h4>
<p>The project started. I set out to work with what seems like the only library for RTP and RTSP
protocol. GNU's ccRTP library is exactly what I need, but in C++ instead of Java. However, it does
have a benefit over any Java product: it will be much lighter, and portable. Since it is my
intention to have Radio run on various types of devices, even very small one, and to have various
servers on a cloud, a lightweight program will help keep costs low and provide easy scability. In
this fashion I decided to build a C++, Linux program.</p>
<p>I decide OK, ccrtp it is. I hit Download from GNU's website and what I downloaded was the source
code. It did not dawn on me that the source was not the binaries, and I simply assumed I had to
compile it.</p>
<p>Long story short, I have to go through hours, days, of learning how to compile from source on Linux.
I learn about <code>configure</code>, I <em>start</em> to learn about <code>cmake</code>, and I spend  a very long time trying to
find the dependencies for compiling libccrtp. It took me very long to find and download
libcommoncpp, libucommon, gcrypt, etc. I finally get a handle of <code>apt</code>, learn the purpose of
<code>configure</code>, and get <code>Makefile</code> to compile successfully.</p>
<p>Then, late at night in bed, feeling proud of myself and finally ready to start actually coding, I
come across the thought that &quot;maybe, just maybe, I should search for the ccrtp's <em>binary</em>.&quot; What I
found was both funny and disappointing:</p>
<pre><code>$ apt search libccrtp
Sorting... Done
Full Text Search... Done
libccrtp-dev/stable 2.0.9-2.3 amd64
  Common C++ class framework for RTP packets - development files

libccrtp-doc/stable,stable 2.0.9-2.3 all
  Documentation files for  GNU ccRTPp library

libccrtp2v5/stable,now 2.0.9-2.3 amd64 [installed,auto-removable]
  Common C++ class framework for RTP packets
</code></pre>
<p>Whatever. At least I learned a lot along the way.</p>
<h3 id="episode-03-visual-studio-failing-to-load-wsl-headers">Episode 03: Visual Studio failing to load WSL headers.</h3>
<h4 id="may-31-2021">May 31, 2021</h4>
<p>Another day, another bump on the way. This bump, however, was more of a warning than an error and,
while I was able to proceed without fixing it, the consequence was very annoying.</p>
<p>When I setup my Visual Studio cmake project, specified it will be cross-compiling using Windows
Subsystem for Linux (WSL), and specified the include directories on CMakeLists.txt, Visual Studio
seemed to accept everything fine and well (no errors or warnings), and I was able to compile my
project without issues, however Visual Studio just couldn't seem to find the proper header symbols.
Everything had a red squigly line under it.</p>
<p>After much research I finally began to understand what Visual Studio does to load the symbols, and
why it was able to compile but not resolve any symbols locally.</p>
<p>When creating a cmake project, in the <code>CMakeSettings.json</code> file there is an optional entry:
<code>remoteCopyAdditionalIncludeDirectories</code>. Visual Studio goes into the directories specified in this
entry and copies all files to a local directory, and uses those files to resolve any necessary
symbols. The files are stored to <code>%USERPROFILE%\AppData\Local\Microsoft\Linux\HeaderCache\1.0</code>.</p>
<p>When I navigated to that directory, there was a single directory <code>wsl_debian</code>, which is the system
I am using for the compiling the project. Inside the directory, however, there were none of the
expected header files. For some reason, Visual Studio simply refuses to copy the necessary files
from the WSL system to this directory, so I tried a different approach: using Visual Studio's remote
system option.</p>
<p>Visual Studio's remote system allows the user to develop on one machine and compile on another,
remotely. It is essentially what it is doing with the WSL setup, but using SSH to communicate with
the remote server. The logic is the same: copy the remote includes to a local directory so
intellisense can do its intellisensing.</p>
<p>I installed the SSH daemon on my Linux (WSL) system and set up the remote system connection on
Visual Studio. I then change the CMakeSettings to use the remote system instead of WSL and let
Visual Studio and CMake do their thing.</p>
<p>I checked the header cache directory again and found that this time there were 2 folders: the WSL
one that already existed and another one with random numbers. The random number one, at last, had
the header files I needed. I copied the header files to the WSL directories and everything worked,
finally.</p>
<p>So, the moral of the story here is: just copy the necessary headers into the local header cache
directory. There is no need for the remote system setup, that's just how I managed to get to this
conclusion.</p>
<h3 id="episode-04-cross-compiling-ccrtp-a-tale-of-libccrtp-2-arm-edition">Episode 04: Cross compiling ccRTP? A tale of libccrtp 2: ARM edition.</h3>
<h4 id="june-5-2021">June 5, 2021</h4>
<p>Armed with the beautiful libccrtp I write a simple client/server program to get familiar with both
the library and the protocol.
I set up wireshark to monitor the transmission of data and after many mistakes I am finally able to
send a file from the client to the server. Great success! I am now ready to drop this into my
Android APK and finally get things going!</p>
<p>Except I'm not...</p>
<p>While getting familiarized with Android's native development kit (NDK) I learn that I overlooked a
pretty big flaw in my portability assessment: I need the c++ libraries built for each <a href="https://wiki.osdev.org/Target_Triplet">target
triplet</a>.</p>
<p>I find that my phone, an old piece of junk, runs on a 32bit ARM processor with hardfloat support. My
brain defaults to &quot;I need to compile libccrtp targetting ARMHF.&quot; And that's what I set out to do.</p>
<p>After an obscene amount of time trying to cross compile libccrtp, realizing that for this build to
work I need all the dependancies also targetting ARMHF, trying to build libucommon from source, I
finally came across an important finding:</p>
<a href="https://packages.debian.org/buster/libccrtp-dev">
<img src="./assets/libccrtp-dev_availableArchs.jpg" alt="libccrtp-dev_availableArchs" width="100%">
</a>
<p>Almost like a glitch in the matrix, I am back at the exact same place I was many, many hours ago,
with only the small intellectual advance that I need to target ARM architecture. Still, progress is
progress. Let's download this:</p>
<pre><code>$ sudo apt install libccrtp-dev:armhf
Reading package lists... Done
Building dependency tree
Reading state information... Done
E: Unable to locate package libccrtp-dev:armhf
</code></pre>
<p>WHAT? Ok, I need to add the architecture to <code>dpkg</code>s arch list. Fine, let's do it:</p>
<pre><code>$dpkg --add-architechture armhf
</code></pre>
<p>Awesome, now let's get that library!</p>
<pre><code>$ sudo apt install libccrtp-dev:armhf
Reading package lists... Done
Building dependency tree
Reading state information... Done
E: Unable to locate package libccrtp-dev:armhf
</code></pre>
<p>Hmm. Still nothing? Well, let me save you the headaches and frustrations...</p>
<p>After adding a new architecture to <code>dpkg</code> we need to update <code>apt</code>'s package list on and then apply
the updates. To do this we just need to call:</p>
<pre><code>apt update &amp;&amp; apt upgrade
</code></pre>
<p>Now apt should have pulled the list of armhf packages, so we try, again:</p>
<pre><code>$ sudo apt install libccrtp-dev:armhf
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following packages were automatically installed and are no longer required:
...
</code></pre>
<p>Yes! It worked! We can verify by checking the contents of the package:</p>
<pre><code>$ dpkg -L libccrtp-dev:armhf | grep libccrtp.so
/usr/lib/arm-linux-gnueabihf/libccrtp.so
</code></pre>
<p>Ok, finally! I am ready! Watchout Android, here I come!</p>
<h3 id="episode-05-ndk-toolchains-and-a-lot-of-headaches.a-tale-of-libccrtp-3-armel-edition">Episode 05: NDK, toolchains, and a lot of headaches. A tale of libccrtp 3: ARM<em>EL</em> edition.</h3>
<h4 id="june-5th-2021">June 5th, 2021</h4>
<p><em>A new day new day. A day for a new battlefield; for new conquests.&quot;</em></p>
<p>I began that day with positive thoughts, for I positively thought that I had conquered the war of
the compilation. Very early into this beautiful, hopeful day for, however, I realized that the
battle I had won was just another one in this war that seemed never to end.</p>
<p>The idea was simple, I thought. <em>&quot;Tomorrow I will compile libradio.dll for amrhf, drop into the
Android project, and start the real work of developing!&quot;</em> I slept like a baby and looked forward
for the new day.</p>
<p>I compile my lib, spend a large amount of time finding out how to drop it into Androi project, drop
it into Android, hit compile, and wait.</p>
<p>...</p>
<p>Doesn't work. The gradle starts to complain about my library. Cannot find sources, doesn't recognize
functions, typical compiler BS.</p>
<p>Everything points me towards using Android NDK (native development kit). Sigh... Ok, another step,
another lesson, and another set of frustrations at the compiler battle field.</p>
<p>I am back at cmake; reading, researching, learning about toolchains, ABIs, and other various things.
I find that things are potentially easy (they were not), and that I might finally be at the edge of
victory again (I was not).</p>
<p>I try to compile and I am faced with an error similar to this:</p>
<pre><code>error: xxx uses VFP register arguments, xxx does not
</code></pre>
<p>What? I reasearch more and, basically, Android NDK uses armeabi and does not support hard floating
point. So what does this mean? It means I have the wrong libs. What I have, referred by <code>apt</code> as
<code>armhf</code>, is <code>arm-linux-gnueabihf</code> and what I need is <code>arm-linux-gnueabi</code>, which <code>apt</code> refers to as
<code>armel</code>.</p>
<p>Basically the rest of the story here is Episode04 with every reference to <code>armhf</code> replace with
<code>armel</code> and a lot less time researching.</p>
<h3 id="episode-06-avoidance-or-how-the-blog-came-to-be">Episode 06: Avoidance; or; How the blog came to be.</h3>

    </body>
</html>
            
